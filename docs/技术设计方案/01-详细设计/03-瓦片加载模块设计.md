# 瓦片加载模块设计

## 模块概述

瓦片加载模块是 OpenEarth 系统的数据管理核心，负责地理瓦片数据的异步加载、缓存管理和 LOD（细节级别）控制。该模块专注于瓦片数据的获取和管理，为瓦片贴图模块提供数据支持，确保用户能够流畅地浏览不同缩放级别的地理信息。

该模块采用基于 Web Workers 的异步加载架构，通过 Worker 线程处理瓦片数据的下载和解码，避免阻塞主线程的渲染性能。缓存管理使用 LRU（最近最少使用）算法实现智能内存管理，通过 Map 数据结构存储瓦片数据，使用双向链表维护访问顺序，当缓存达到容量限制时自动淘汰最久未使用的瓦片。LOD 管理基于屏幕空间误差（Screen Space Error）算法，根据相机距离、瓦片大小和屏幕分辨率动态计算合适的细节级别，通过四叉树结构组织瓦片层次关系，实现平滑的 LOD 切换。网络请求采用 Fetch API 和 AbortController 实现可取消的异步请求，支持重试机制和超时控制，通过 Promise 和 async/await 语法简化异步流程。数据格式支持多种瓦片服务协议，包括 TMS、WMTS、XYZ 等标准协议，通过适配器模式统一不同数据源的接口。性能优化采用视锥剔除技术，只加载相机视野内的瓦片，通过空间索引和边界框检测快速筛选可见瓦片，减少不必要的网络请求和内存占用。

## 模块职责

- **瓦片数据加载**：异步加载地理瓦片数据，支持多种数据源和协议
- **缓存管理**：基于 LRU 策略的智能缓存，优化内存使用和加载性能
- **LOD 管理**：动态计算和调整细节级别，确保数据质量和加载性能平衡
- **队列管理**：加载任务队列和优先级调度，优化网络资源使用
- **数据源管理**：支持多种瓦片服务协议和数据格式
- **数据接口**：为瓦片贴图模块提供瓦片数据访问接口

## 类图设计

```mermaid
classDiagram
    class TileLoader {
        -cache: TileCache
        -queue: LoadingQueue
        -lodManager: LODManager
        -dataSources: Map~string, DataSource~
        -isInitialized: boolean
        -maxConcurrentLoads: number
        -currentLoads: number
        +constructor(config: TileLoaderConfig)
        +initialize(): Promise~void~
        +dispose(): void
        +loadTile(tileKey: TileKey): Promise~Tile~
        +preloadTiles(tileKeys: TileKey[]): void
        +clearCache(): void
        +updateCameraPosition(position: Vector3): void
        +getCacheStats(): CacheStats
    }
    
    class TileKey {
        +x: number
        +y: number
        +z: number
        +source: string
        +layer: string
        +equals(other: TileKey): boolean
        +toString(): string
        +getParent(): TileKey
        +getChildren(): TileKey[]
    }
    
    class Tile {
        -key: TileKey
        -data: ArrayBuffer
        -isLoaded: boolean
        -loadTime: number
        -lastAccessed: number
        +constructor(key: TileKey)
        +getData(): ArrayBuffer
        +isLoaded(): boolean
        +dispose(): void
    }
    
    class TileCache {
        -cache: Map~string, Tile~
        -maxSize: number
        -currentSize: number
        -accessOrder: LinkedList~string~
        +constructor(maxSize: number)
        +get(key: string): Tile | null
        +set(key: string, tile: Tile): void
        +remove(key: string): void
        +clear(): void
        +getStats(): CacheStats
        +evictLRU(): void
    }
    
    class LoadingQueue {
        -highPriority: PriorityQueue~LoadingTask~
        -normalPriority: PriorityQueue~LoadingTask~
        -lowPriority: PriorityQueue~LoadingTask~
        -activeTasks: Set~string~
        -maxConcurrent: number
        +constructor(maxConcurrent: number)
        +enqueue(task: LoadingTask): void
        +dequeue(): LoadingTask | null
        +remove(key: string): void
        +clear(): void
        +getQueueSize(): number
    }
    
    class LoadingTask {
        -tileKey: TileKey
        -priority: TaskPriority
        -retryCount: number
        -maxRetries: number
        -createdAt: number
        +constructor(tileKey: TileKey, priority: TaskPriority)
        +getTileKey(): TileKey
        +getPriority(): TaskPriority
        +incrementRetry(): void
        +canRetry(): boolean
        +getAge(): number
    }
    
    class LODManager {
        -cameraPosition: Vector3
        -tileSize: number
        -maxZoom: number
        -minZoom: number
        -lodThresholds: number[]
        +constructor(config: LODConfig)
        +updateCameraPosition(position: Vector3): void
        +calculateLOD(tileKey: TileKey): number
        +shouldLoadTile(tileKey: TileKey): boolean
        +getVisibleTiles(bounds: BoundingBox): TileKey[]
        +getLODLevel(distance: number): number
    }
    
    class DataSource {
        -name: string
        -type: string
        -urlTemplate: string
        -attribution: string
        -maxZoom: number
        -minZoom: number
        -format: string
        +constructor(config: DataSourceConfig)
        +getName(): string
        +getType(): string
        +getUrl(tileKey: TileKey): string
        +supportsZoom(zoom: number): boolean
        +getAttribution(): string
    }
    
    class TileLoaderConfig {
        +maxCacheSize: number
        +maxConcurrentLoads: number
        +retryAttempts: number
        +retryDelay: number
        +timeout: number
        +dataSources: DataSourceConfig[]
        +lodConfig: LODConfig
    }
    
    class DataSourceConfig {
        +name: string
        +type: string
        +url: string
        +attribution: string
        +maxZoom: number
        +minZoom: number
        +format: string
    }
    
    class LODConfig {
        +maxZoom: number
        +minZoom: number
        +tileSize: number
        +lodThresholds: number[]
        +frustumCulling: boolean
    }
    
    class CacheStats {
        +size: number
        +maxSize: number
        +hitRate: number
        +missRate: number
        +evictionCount: number
    }
    
    class BoundingBox {
        +minX: number
        +minY: number
        +maxX: number
        +maxY: number
        +contains(x: number, y: number): boolean
        +intersects(other: BoundingBox): boolean
    }
    
    class TaskPriority {
        <<enumeration>>
        HIGH
        NORMAL
        LOW
    }
    
    TileLoader --> TileCache : 使用缓存
    TileLoader --> LoadingQueue : 使用队列
    TileLoader --> LODManager : 使用LOD管理
    TileLoader --> DataSource : 使用数据源
    TileLoader --> TileLoaderConfig : 使用配置
    
    TileCache --> Tile : 缓存瓦片
    LoadingQueue --> LoadingTask : 管理任务
    LODManager --> TileKey : 计算LOD
    DataSource --> TileKey : 生成URL
    
    LoadingTask --> TileKey : 包含瓦片键
    LoadingTask --> TaskPriority : 使用优先级
    
    Tile --> TileKey : 包含键值
```

## 状态图设计

```mermaid
stateDiagram-v2
    [*] --> 未初始化
    
    未初始化 --> 初始化中: initialize()
    初始化中 --> 数据源配置中: 创建数据源
    数据源配置中 --> 缓存初始化中: 数据源配置完成
    缓存初始化中 --> 队列初始化中: 缓存初始化完成
    队列初始化中 --> 运行中: 所有组件初始化成功
    队列初始化中 --> 初始化失败: 组件初始化错误
    初始化失败 --> 未初始化: 重新初始化
    
    运行中 --> 加载瓦片中: loadTile()
    加载瓦片中 --> 检查缓存: 开始加载
    检查缓存 --> 缓存命中: 瓦片在缓存中
    检查缓存 --> 队列任务: 瓦片不在缓存中
    缓存命中 --> 运行中: 返回缓存瓦片
    队列任务 --> 网络请求中: 从队列获取任务
    网络请求中 --> 请求成功: 网络请求完成
    网络请求中 --> 请求失败: 网络请求错误
    请求成功 --> 缓存存储: 数据加载成功
    缓存存储 --> 运行中: 存储完成
    请求失败 --> 重试检查: 检查重试次数
    重试检查 --> 队列任务: 可以重试
    重试检查 --> 运行中: 重试次数超限
    队列任务 --> 运行中: 队列为空
    
    运行中 --> 预加载中: preloadTiles()
    预加载中 --> 运行中: 预加载完成
    
    运行中 --> 缓存清理中: clearCache()
    缓存清理中 --> 运行中: 清理完成
    
    运行中 --> 相机更新中: updateCameraPosition()
    相机更新中 --> LOD计算中: 位置更新
    LOD计算中 --> 可见瓦片计算中: LOD计算完成
    可见瓦片计算中 --> 运行中: 计算完成
    
    运行中 --> 暂停: 系统暂停
    暂停 --> 运行中: 系统恢复
    
    运行中 --> 销毁中: dispose()
    暂停 --> 销毁中: dispose()
    销毁中 --> 已销毁: 销毁完成
    已销毁 --> [*]
```

## 序列图设计

```mermaid
sequenceDiagram
    participant Globe
    participant TileLoader
    participant TileCache
    participant LoadingQueue
    participant LODManager
    participant DataSource
    participant Network
    
    Globe->>TileLoader: initialize()
    TileLoader->>DataSource: 创建数据源实例
    TileLoader->>TileCache: 初始化缓存
    TileLoader->>LoadingQueue: 初始化队列
    TileLoader->>LODManager: 初始化LOD管理器
    
    loop 渲染循环
        Globe->>TileLoader: updateCameraPosition(position)
        TileLoader->>LODManager: updateCameraPosition(position)
        LODManager->>LODManager: 计算可见瓦片
        LODManager->>TileLoader: 返回需要加载的瓦片列表
        
        loop 每个需要加载的瓦片
            TileLoader->>TileCache: get(tileKey)
            alt 缓存命中
                TileCache->>TileLoader: 返回缓存瓦片
            else 缓存未命中
                TileLoader->>LoadingQueue: enqueue(loadingTask)
                LoadingQueue->>LoadingQueue: 按优先级排序
            end
        end
        
        loop 处理加载队列
            LoadingQueue->>TileLoader: dequeue()
            TileLoader->>DataSource: getUrl(tileKey)
            DataSource->>TileLoader: 返回瓦片URL
            TileLoader->>Network: 请求瓦片数据
            Network->>TileLoader: 返回瓦片数据
            TileLoader->>TileCache: set(tileKey, tile)
            TileCache->>TileCache: 更新缓存
        end
    end
    
    Globe->>TileLoader: loadTile(tileKey)
    TileLoader->>TileCache: get(tileKey)
    alt 缓存命中
        TileCache->>TileLoader: 返回瓦片
        TileLoader->>Globe: 返回瓦片
    else 缓存未命中
        TileLoader->>LoadingQueue: enqueue(highPriorityTask)
        LoadingQueue->>DataSource: 获取URL
        DataSource->>Network: 请求数据
        Network->>TileLoader: 返回数据
        TileLoader->>TileCache: 存储瓦片
        TileLoader->>Globe: 返回瓦片
    end
    
    Globe->>TileLoader: preloadTiles(tileKeys)
    loop 每个瓦片键
        TileLoader->>LoadingQueue: enqueue(lowPriorityTask)
    end
    
    Globe->>TileLoader: clearCache()
    TileLoader->>TileCache: clear()
    TileCache->>TileCache: 清理所有缓存
    
    Globe->>TileLoader: dispose()
    TileLoader->>TileCache: dispose()
    TileLoader->>LoadingQueue: dispose()
    TileLoader->>LODManager: dispose()
    TileLoader->>DataSource: dispose()
```

## 核心算法

### LOD 计算算法

```typescript
// LOD 级别计算
function calculateLOD(tileKey: TileKey, cameraPosition: Vector3): number {
    const tileCenter = getTileCenter(tileKey);
    const distance = Vector3.Distance(cameraPosition, tileCenter);
    const tileSize = getTileSize(tileKey.z);
    const screenSpaceError = (tileSize / distance) * screenHeight;
    
    // 根据屏幕空间误差计算合适的 LOD 级别
    for (let lod = 0; lod < lodThresholds.length; lod++) {
        if (screenSpaceError <= lodThresholds[lod]) {
            return lod;
        }
    }
    return lodThresholds.length - 1;
}
```

### LRU 缓存算法

```typescript
// LRU 缓存淘汰策略
function evictLRU(): void {
    if (currentSize <= maxSize) return;
    
    const toEvict = Math.ceil(currentSize * 0.1); // 淘汰 10%
    for (let i = 0; i < toEvict; i++) {
        const oldestKey = accessOrder.removeFirst();
        const tile = cache.get(oldestKey);
        if (tile) {
            tile.dispose();
            cache.delete(oldestKey);
            currentSize--;
        }
    }
}
```

### 优先级队列算法

```typescript
// 优先级任务调度
function scheduleTask(task: LoadingTask): void {
    switch (task.getPriority()) {
        case TaskPriority.HIGH:
            highPriority.enqueue(task);
            break;
        case TaskPriority.NORMAL:
            normalPriority.enqueue(task);
            break;
        case TaskPriority.LOW:
            lowPriority.enqueue(task);
            break;
    }
    
    processQueue();
}
```

## 性能优化策略

### 缓存策略
- **LRU 淘汰**：基于最近最少使用原则淘汰缓存
- **内存限制**：设置最大缓存大小，防止内存溢出
- **预加载**：根据相机移动方向预加载相邻瓦片

### 网络优化
- **并发控制**：限制同时进行的网络请求数量
- **重试机制**：网络失败时自动重试，支持指数退避
- **超时控制**：设置请求超时时间，避免长时间等待

### LOD 优化
- **视锥剔除**：只加载相机视野内的瓦片
- **距离计算**：根据相机距离动态调整瓦片精度
- **平滑过渡**：LOD 级别切换时的平滑过渡效果

## 错误处理

### 网络错误处理
- **重试机制**：网络请求失败时自动重试
- **降级策略**：高精度瓦片加载失败时使用低精度瓦片
- **错误日志**：记录详细的错误信息用于调试

### 内存管理
- **内存监控**：实时监控内存使用情况
- **自动清理**：内存不足时自动清理缓存
- **资源释放**：及时释放不再使用的纹理和缓冲区

### 数据验证
- **格式检查**：验证加载的瓦片数据格式
- **完整性检查**：确保瓦片数据完整无损
- **异常处理**：处理损坏或无效的瓦片数据
